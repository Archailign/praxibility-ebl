package org.example.ebl; import org.antlr.v4.runtime.*; import org.antlr.v4.runtime.tree.*; import java.nio.file.Path; import java.util.*; import java.util.regex.*;
public class EBLSemanticValidator extends EBLBaseListener {
  private static final Set<String> ALLOWED_TYPES = Set.of("UUID","String","Integer","Currency","Ratio","Date","Enum","JSON","Boolean");
  private final List<String> errors = new ArrayList<>(); private final List<String> warnings = new ArrayList<>(); private final Set<String> dataObjects = new HashSet<>(); private final Set<String> entities = new HashSet<>(); private final Set<String> itAssets = new HashSet<>(); private final EBLDictionarySymbols dict; private final Deque<ProcessScope> procStack = new ArrayDeque<>(); private final boolean warnUnknownAssets = !"false".equalsIgnoreCase(System.getProperty("ebl.warnUnknownAssets","true"));
  private static class ProcessScope { Set<String> declared = new HashSet<>(); Set<String> used = new HashSet<>(); }
  private final Map<String, Set<String>> entityEnumValues = new HashMap<>(); private final Map<String, String> entityEnumDefaults = new HashMap<>();
  public EBLSemanticValidator(EBLDictionarySymbols d){ this.dict = d; }
  @Override public void enterDataObject(EBLParser.DataObjectContext ctx){ String id = ctx.IDENTIFIER(0).getText(); dataObjects.add(id);
    for (EBLParser.FieldDefContext f : ctx.fieldDef()) { String field=f.IDENTIFIER().getText(); String type=f.type().getText(); if (!ALLOWED_TYPES.contains(type)) errors.add("DataObject '"+id+"': field '"+field+"' uses unsupported type '"+type+"'");
      double min=Double.NaN,max=Double.NaN; boolean hasValues=false; for (EBLParser.FieldAttrContext a : f.fieldAttr()){ String t=a.getText(); if (t.startsWith("min=")) try{min=Double.parseDouble(t.substring(4));}catch(Exception ignore){} if (t.startsWith("max=")) try{max=Double.parseDouble(t.substring(4));}catch(Exception ignore){} if (t.startsWith("values=")) hasValues=true; } if (!Double.isNaN(min) && !Double.isNaN(max) && min>max) errors.add("DataObject '"+id+"': field '"+field+"' has min>max ("+min+" > "+max+")"); if ("Enum".equals(type) && !hasValues) warnings.add("DataObject '"+id+"': field '"+field+"' type Enum without explicit values= list."); }
    if (ctx.policyDef()==null || ctx.policyDef().isEmpty()) errors.add("DataObject '"+id+"': must declare Policies."); if (ctx.resourceBlock()==null) errors.add("DataObject '"+id+"': must define Resources."); }
  private final List<Map.Entry<String,String>> pendingEntityRefs = new ArrayList<>();
  @Override public void enterEntity(EBLParser.EntityContext ctx){ String name=ctx.IDENTIFIER(0).getText(); entities.add(name); pendingEntityRefs.add(Map.entry(name, ctx.IDENTIFIER(1).getText()));
    for (EBLParser.PropertyContext p : ctx.property()){ String prop=p.IDENTIFIER().getText(); String type=p.propertyDef().type().getText(); if (!ALLOWED_TYPES.contains(type)) errors.add("Entity '"+name+"': property '"+prop+"' uses unsupported type '"+type+"'"); if ("Enum".equals(type)){ String key=name+"."+prop; Set<String> vals=new HashSet<>(); String def=null; for (EBLParser.PropertyAttrContext a : p.propertyDef().propertyAttr()){ String txt=a.getText(); if (txt.startsWith("values:")){ int i=txt.indexOf('['), j=txt.indexOf(']'); if (i>0 && j>i){ String inside=txt.substring(i+1,j); for (String v : inside.split(",")) vals.add(v.replaceAll("[\\[\\]\\s\"']","")); } } if (txt.startsWith("default:")) def = txt.substring("default:".length()).replaceAll("[:\\s\"']",""); } if (!vals.isEmpty()) entityEnumValues.put(key, vals); if (def!=null) entityEnumDefaults.put(key, def); } } }
  @Override public void exitEblDefinition(EBLParser.EblDefinitionContext ctx){ for (var e : pendingEntityRefs) if (!dataObjects.contains(e.getValue())) errors.add("Entity '"+e.getKey()+"' references missing DataObject '"+e.getValue()+"' (dataRef)."); for (var e : entityEnumDefaults.entrySet()){ String key=e.getKey(), def=e.getValue(); Set<String> vals=entityEnumValues.getOrDefault(key, Set.of()); if (!vals.isEmpty() && !vals.contains(def)) errors.add("Enum default '"+def+"' not in values for "+key); } }
  @Override public void enterItAsset(EBLParser.ItAssetContext ctx){ itAssets.add(ctx.IDENTIFIER(0).getText()); }
  @Override public void enterProcess(EBLParser.ProcessContext ctx){ ProcessScope s = new ProcessScope(); String full=ctx.getText(); int ai=full.indexOf("Actors:["); if (ai>=0){ int end=full.indexOf("]", ai); if (end>ai){ String inside=full.substring(ai+"Actors:[".length(), end); for (String tok : inside.split(",")){ String t=tok.replaceAll("[^A-Za-z0-9_]+","").trim(); if(!t.isEmpty()) s.declared.add(t); } } } procStack.push(s); }
  @Override public void exitProcess(EBLParser.ProcessContext ctx){ ProcessScope s = procStack.pop(); for (String a : s.declared){ if (!s.used.contains(a)) warnings.add("Process: actor '"+a+"' declared but never used in Actions."); } }
  @Override public void enterAction(EBLParser.ActionContext ctx){ String line=ctx.getText(); java.util.regex.Matcher m=java.util.regex.Pattern.compile("^\\s*-\\s*([A-Za-z_][A-Za-z0-9_]*)\\s+([A-Za-z][A-Za-z0-9_]*)\\b").matcher(line); if (!m.find()){ warnings.add("Action missing explicit 'Actor Verb' prefix; use '- <Actor> <Verb> ...'"); return; } String actor=m.group(1), verb=m.group(2);
    ProcessScope s = procStack.isEmpty()? null : procStack.peek(); if (s!=null) s.used.add(actor);
    if (dict!=null){ if (!dict.hasActor(actor)) warnings.add("Action actor '"+actor+"' not found in dictionary."); if (!dict.hasVerb(verb)) warnings.add("Verb '"+verb+"' not in domain verb list."); if (!dict.permittedByAnyActor(verb)) warnings.add("Verb '"+verb+"' is never permitted by any actor in the domain whitelist."); if (!dict.actorAllowsVerb(actor, verb)) warnings.add("Actor '"+actor+"' not allowed to perform '"+verb+"' by whitelist.");
      String needed=dict.permForVerb(verb).orElse(null); java.util.regex.Matcher d=java.util.regex.Pattern.compile("\\b(DO_[A-Za-z0-9_]+)\\s*(Input|Output)?\\b").matcher(line); while (d.find()){ String dobj=d.group(1), io=d.group(2); if (io==null && needed!=null) io = "write".equals(needed)? "Input" : "Output"; boolean ok = "Input".equals(io) ? dict.canWrite(actor, dobj) : dict.canRead(actor, dobj); if (!ok) warnings.add("Actor '"+actor+"' lacks "+("Input".equals(io)?"WRITE":"READ")+" permission on '"+dobj+"' (verb '"+verb+"')."); } } }
  private void checkFreeText(String where, String text){ if (text==null) return; for (String kw : dict.reserved){ if (java.util.regex.Pattern.compile("\\b"+java.util.regex.Pattern.quote(kw)+"\\b", java.util.regex.Pattern.CASE_INSENSITIVE).matcher(text).find()) warnings.add(where + ": free-text contains reserved keyword '"+kw+"'; consider quoting or using structured fields."); } }
  @Override public void enterValidation(EBLParser.ValidationContext ctx){ String t = ctx.getText().replaceFirst("^\\s*-\\s*", ""); checkFreeText("Validation", t); }
  @Override public void enterRuleDef(EBLParser.RuleDefContext ctx){ String desc=ctx.STRING(0).getText(); String trig=ctx.TEXT(0).getText(); checkFreeText("Rule.Description", desc); checkFreeText("Rule.Trigger", trig); }
  @Override public void enterReport(EBLParser.ReportContext ctx){ String q=ctx.TEXT(0).getText(); checkFreeText("Report.Query", q); }
  @Override public void enterRelationshipDef(EBLParser.RelationshipDefContext ctx){ String name=ctx.IDENTIFIER(0).getText(); String from=ctx.IDENTIFIER(1).getText(); String to=ctx.IDENTIFIER(2).getText(); String type=ctx.IDENTIFIER(3).getText();
    if (warnUnknownAssets){ boolean fromKnown = entities.contains(from) || itAssets.contains(from) || (dict!=null && dict.hasActor(from)); boolean toKnown = entities.contains(to) || itAssets.contains(to) || (dict!=null && dict.hasActor(to)); if (!fromKnown) warnings.add("Relationship '"+name+"': From='"+from+"' not a known Entity/ITAsset/Actor."); if (!toKnown) warnings.add("Relationship '"+name+"': To='"+to+"' not a known Entity/ITAsset/Actor."); }
    if (dict!=null && !dict.isRelType(type)) warnings.add("Relationship '"+name+"': Type '"+type+"' is not allowed.");
    if ("hosted_on".equals(type)){ boolean hasAppCat = dataObjects.contains("DO_ApplicationCatalog"); boolean hasPlatReg= dataObjects.contains("DO_PlatformRegistry"); if (!hasAppCat && !hasPlatReg) warnings.add("Relationship '"+name+"': hosted_on used but neither DO_ApplicationCatalog nor DO_PlatformRegistry defined."); }
  }
  public List<String> getErrors(){ return errors; } public List<String> getWarnings(){ return warnings; }
  public static void main(String[] args) throws Exception { if (args.length<2){ System.err.println("Usage: java org.example.ebl.EBLSemanticValidator <dictionary.json> <file.ebl>"); System.exit(1); }
    CharStream input = CharStreams.fromPath(Path.of(args[1])); EBLLexer lexer = new EBLLexer(input); CommonTokenStream tokens = new CommonTokenStream(lexer); EBLParser parser = new EBLParser(tokens); ParseTree tree = parser.eblDefinition();
    EBLDictionarySymbols dict = EBLDictionarySymbols.fromPath(args[0]); EBLSemanticValidator v = new EBLSemanticValidator(dict); ParseTreeWalker.DEFAULT.walk(v, tree);
    if (!v.getWarnings().isEmpty()){ System.err.println("Warnings:"); for (String w : v.getWarnings()) System.err.println("  - " + w); }
    if (!v.getErrors().isEmpty()){ System.err.println("Errors:"); for (String e : v.getErrors()) System.err.println("  - " + e); System.exit(2); }
    System.out.println("Semantic validation passed."); }
}
